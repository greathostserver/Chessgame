<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chess Game | بازی شطرنج</title>
<style>
:root {
  --board-light: #f0d9b5;
  --board-dark: #b58863;
  --piece-white-color: #ffffff;
  --piece-black-color: #111111;
  --accent: #0ea5e9;
  --bg: #0b1020;
  --text: #e8edf2;
  --warning: #ef4444;
  --ok: #22c55e;
}
* { box-sizing: border-box; }
html, body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Naskh Arabic", "Sahel", Arial, sans-serif;
}
.app {
  min-height: 100vh;
  display: grid;
  place-items: center;
  padding: 16px;
}
.container {
  width: 100%;
  max-width: 1100px;
  display: grid;
  grid-template-rows: auto auto 1fr auto;
  align-items: center;
  justify-items: center;
  gap: 16px;
  text-align: center;
}
header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
  width: 100%;
}
header .title { font-weight: 700; letter-spacing: 0.3px; }
.controls {
  display: grid;
  grid-template-columns: repeat(3, minmax(260px, 1fr));
  gap: 12px;
  width: 100%;
  max-width: 1000px;
}
@media (max-width: 980px) { .controls { grid-template-columns: 1fr; } }
.card {
  width: 100%;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  padding: 12px;
  backdrop-filter: blur(6px);
}
.row {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 8px;
}
label { font-size: 0.95rem; opacity: 0.92; font-weight: 600; }
select, button, input[type="color"] {
  appearance: none;
  border: 1px solid rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.08);
  color: var(--text);
  padding: 10px 12px;
  border-radius: 10px;
  cursor: pointer;
  outline: none;
  transition: border-color .2s, transform .05s;
  min-width: 160px;
}
button.primary {
  background: var(--accent);
  border-color: transparent;
  color: #082032;
  font-weight: 700;
}
button:active { transform: translateY(1px); }
.layout {
  display: grid;
  grid-template-columns: minmax(280px, 520px) minmax(280px, 520px);
  gap: 16px;
  align-items: start;
  justify-items: center;
  width: 100%;
}
@media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }
.board-wrap {
  width: min(92vw, 520px);
  height: min(92vw, 520px);
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 10px 40px rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.08);
}
.board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  width: 100%;
  height: 100%;
  user-select: none;
}
.square {
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color .12s;
}
.light { background-color: var(--board-light); }
.dark  { background-color: var(--board-dark); }
.highlight { outline: 3px solid rgba(14,165,233,0.8); outline-offset: -3px; }
.hint { box-shadow: inset 0 0 0 4px rgba(14,165,233,0.25); }
.illegal { animation: blink .25s 2; }
@keyframes blink { 0% { filter: saturate(1.2); } 50% { filter: saturate(0.5); } 100% { filter: saturate(1.2); } }
.piece {
  width: 88%;
  height: 88%;
  display: grid;
  place-items: center;
  cursor: grab;
  border-radius: 8px;
  font-size: clamp(28px, 6.5vw, 38px);
  transition: transform .08s ease;
  background: transparent;
}
.piece.white { color: var(--piece-white-color); text-shadow: 0 1px 0 rgba(0,0,0,0.25); }
.piece.black { color: var(--piece-black-color); text-shadow: 0 1px 0 rgba(255,255,255,0.15); }
.piece:active { cursor: grabbing; transform: translateY(-1px); }
.side {
  display: grid;
  gap: 12px;
  width: 100%;
  max-width: min(92vw, 520px);
}
.status {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}
.status .badge {
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.14);
  font-size: 0.9rem;
}
.history {
  min-height: 220px;
  max-height: 320px;
  overflow: auto;
}
.history-item {
  display: grid;
  grid-template-columns: 48px 1fr 1fr;
  gap: 8px;
  align-items: center;
  padding: 6px 8px;
  border-bottom: 1px dashed rgba(255,255,255,0.08);
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace;
}
.history-item .num { opacity: 0.75; }
.warning { color: var(--warning); font-weight: 700; }
.ok { color: var(--ok); font-weight: 700; }
footer { opacity: 0.7; font-size: 0.9rem; }
</style>
</head>
<body>
<div class="app">
  <div class="container">
    <header>
      <div class="title">Chess • بازی شطرنج • الشطرنج</div>
      <div class="row">
        <button id="newGameBtn" class="primary"></button>
        <button id="flipBtn"></button>
        <button id="undoBtn"></button>
      </div>
    </header>

    <div class="controls">
      <div class="card">
        <label id="langLabel"></label>
        <div class="row">
          <select id="langSelect">
            <option value="fa">انتخاب زبان: فارسی</option>
            <option value="ar">اختيار اللغة: العربية</option>
            <option value="en">Choose language: English</option>
          </select>
          <button id="applyLang" class="primary"></button>
        </div>
        <div class="row"><span id="startPrompt"></span></div>
      </div>

      <div class="card">
        <label id="themeLabel"></label>
        <div class="row">
          <div>
            <div style="font-size:0.9rem; opacity:0.85;" id="lightLabel"></div>
            <input type="color" id="lightColor" value="#f0d9b5" />
          </div>
          <div>
            <div style="font-size:0.9rem; opacity:0.85;" id="darkLabel"></div>
            <input type="color" id="darkColor" value="#b58863" />
          </div>
          <div>
            <div style="font-size:0.9rem; opacity:0.85;" id="whitePieceLabel"></div>
            <input type="color" id="whitePieceColor" value="#ffffff" />
          </div>
          <div>
            <div style="font-size:0.9rem; opacity:0.85;" id="blackPieceLabel"></div>
            <input type="color" id="blackPieceColor" value="#111111" />
          </div>
          <button id="applyTheme" class="primary"></button>
        </div>
      </div>

      <div class="card">
        <label id="aiLabel"></label>
        <div class="row">
          <select id="aiSide">
            <option value="none">انتخاب سمت هوش مصنوعی: غیرفعال</option>
            <option value="w">انتخاب سمت هوش مصنوعی: سفید</option>
            <option value="b">انتخاب سمت هوش مصنوعی: سیاه</option>
          </select>
          <select id="aiLevel">
            <option value="0">سطح هوش مصنوعی: 0 (تصادفی)</option>
            <option value="1">سطح هوش مصنوعی: 1 (پایه)</option>
            <option value="2">سطح هوش مصنوعی: 2</option>
            <option value="3">سطح هوش مصنوعی: 3</option>
            <option value="4">سطح هوش مصنوعی: 4 (آلفا–بتا)</option>
            <option value="5">سطح هوش مصنوعی: 5 (PST + آلفا–بتا)</option>
          </select>
          <button id="applyAI" class="primary"></button>
        </div>
      </div>
    </div>

    <div class="layout">
      <div class="board-wrap"><div id="board" class="board"></div></div>
      <div class="side">
        <div class="card status">
          <div class="badge" id="turnBadge"></div>
          <div class="badge" id="stateBadge"></div>
        </div>
        <div class="card history" id="history"></div>
        <div class="card"><div id="message"></div></div>
      </div>
    </div>

    <footer>Hosted on GitHub Pages • Client-side only • No external dependencies</footer>
  </div>
</div>

<audio id="moveSound" preload="auto">
  <source src="data:audio/wav;base64,UklGRoYBAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YYMBAAAAgP8AAP8AgICAf39/f4CAgICAf39/gICAf4CAgH9/f4CAgICAf39/f4CAgICAf39/gICAf4CAgH9/f4CAgICAf39/f4CAgICAf39/gICAf4CAgA==" type="audio/wav">
</audio>
<audio id="illegalSound" preload="auto">
  <source src="data:audio/wav;base64,UklGRqIBAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YY0BAAAAAP8AAICAf39/gICAf39/gICAf39/gP8AAP8AAP8AAP8AAICAf39/gICAf39/gICAf39/gP8AAP8AAP8AAP8A" type="audio/wav">
</audio>

<script>
const i18n = {
  fa: {
    newGame: "شروع بازی جدید",
    flip: "چرخش صفحه",
    undo: "بازگشت حرکت",
    langLabel: "انتخاب زبان",
    applyLang: "اعمال زبان",
    startPrompt: "قبل از ورود، زبان را انتخاب کنید.",
    themeLabel: "تنظیمات ظاهر و رنگ‌ها",
    lightLabel: "خانه‌های روشن",
    darkLabel: "خانه‌های تیره",
    whitePieceLabel: "رنگ مهره‌های سفید",
    blackPieceLabel: "رنگ مهره‌های سیاه",
    applyTheme: "اعمال رنگ‌ها",
    aiLabel: "هوش مصنوعی: سمت و سطح",
    applyAI: "اعمال هوش مصنوعی",
    turnWhite: "نوبت سفید",
    turnBlack: "نوبت سیاه",
    statePlaying: "در حال بازی",
    stateCheck: "کیش!",
    stateMate: "کیش و مات",
    stateStalemate: "بن‌بست",
    illegal: "حرکت غیرقانونی است.",
    moved: "حرکت انجام شد.",
    historyTitle: "تاریخچه حرکات"
  },
  ar: {
    newGame: "بدء لعبة جديدة",
    flip: "تدوير اللوحة",
    undo: "تراجع عن الحركة",
    langLabel: "اختر اللغة",
    applyLang: "تطبيق اللغة",
    startPrompt: "اختر اللغة قبل الدخول.",
    themeLabel: "إعدادات المظهر والألوان",
    lightLabel: "المربعات الفاتحة",
    darkLabel: "المربعات الداكنة",
    whitePieceLabel: "لون قطع الأبيض",
    blackPieceLabel: "لون قطع الأسود",
    applyTheme: "تطبيق الألوان",
    aiLabel: "الذكاء الاصطناعي: الجانب والمستوى",
    applyAI: "تطبيق الذكاء الاصطناعي",
    turnWhite: "دور الأبيض",
    turnBlack: "دور الأسود",
    statePlaying: "جارٍ اللعب",
    stateCheck: "كش!",
    stateMate: "كش مات",
    stateStalemate: "تعادل",
    illegal: "حركة غير قانونية.",
    moved: "تمت الحركة.",
    historyTitle: "سجل الحركات"
  },
  en: {
    newGame: "New game",
    flip: "Flip board",
    undo: "Undo move",
    langLabel: "Choose language",
    applyLang: "Apply language",
    startPrompt: "Pick a language before entering.",
    themeLabel: "Appearance & colors",
    lightLabel: "Light squares",
    darkLabel: "Dark squares",
    whitePieceLabel: "White pieces color",
    blackPieceLabel: "Black pieces color",
    applyTheme: "Apply colors",
    aiLabel: "AI: side & level",
    applyAI: "Apply AI",
    turnWhite: "White to move",
    turnBlack: "Black to move",
    statePlaying: "Playing",
    stateCheck: "Check!",
    stateMate: "Checkmate",
    stateStalemate: "Stalemate",
    illegal: "Illegal move.",
    moved: "Move done.",
    historyTitle: "Move history"
  }
};

const state = {
  lang: localStorage.getItem('chess_lang') || 'fa',
  flipped: false,
  aiSide: localStorage.getItem('chess_ai_side') || 'none',
  aiLevel: parseInt(localStorage.getItem('chess_ai_level') || '0', 10),
  theme: {
    light: localStorage.getItem('chess_light') || '#f0d9b5',
    dark: localStorage.getItem('chess_dark') || '#b58863',
    pieceW: localStorage.getItem('chess_pieceW') || '#ffffff',
    pieceB: localStorage.getItem('chess_pieceB') || '#111111'
  }
};

const files = ['a','b','c','d','e','f','g','h'];
const ranks = ['8','7','6','5','4','3','2','1'];
function idxToCoord(i) { return files[i%8] + ranks[Math.floor(i/8)]; }
function coordToIdx(coord) { const f = files.indexOf(coord[0]); const r = ranks.indexOf(coord[1]); return r*8 + f; }
function inBoardIdx(i) { return i >= 0 && i < 64; }
function isWhite(p) { return p && p === p.toUpperCase(); }
function isBlack(p) { return p && p === p.toLowerCase(); }

let board = [];
let whiteToMove = true;
let castleRights = { K:true, Q:true, k:true, q:true };
let enPassant = null;
let halfmoveClock = 0;
let fullmoveNumber = 1;
const history = [];
const undoStack = [];
const initialFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR";

function loadFEN(fen) {
  board = Array(64).fill(null);
  const parts = fen.split('/');
  let i = 0;
  for (let row=0; row<8; row++) {
    const s = parts[row];
    for (const ch of s) {
      if (/[1-8]/.test(ch)) i += parseInt(ch,10);
      else board[i++] = ch;
    }
  }
  whiteToMove = true;
  castleRights = {K:true,Q:true,k:true,q:true};
  enPassant = null;
  halfmoveClock = 0;
  fullmoveNumber = 1;
  history.length = 0;
  undoStack.length = 0;
}

function findKingIdx(whiteSide) {
  const target = whiteSide ? 'K' : 'k';
  for (let i=0;i<64;i++) if (board[i] === target) return i;
  return -1;
}
function knightReach(from,to) {
  const fx = from % 8, fy = Math.floor(from/8);
  const tx = to % 8, ty = Math.floor(to/8);
  const dx = Math.abs(tx - fx), dy = Math.abs(ty - fy);
  return dx*dy === 2;
}
function kingReach(from,to) {
  const fx = from % 8, fy = Math.floor(from/8);
  const tx = to % 8, ty = Math.floor(to/8);
  return Math.max(Math.abs(tx - fx), Math.abs(ty - fy)) === 1;
}
function sameLine(from, to, step) {
  const fx = from % 8, fy = Math.floor(from/8);
  const tx = to % 8, ty = Math.floor(to/8);
  const sfx = step % 8, sfy = Math.floor(step/8);
  if (Math.abs(sfx) === 1 && sfy === 0) return fy === ty;
  if (sfx === 0 && Math.abs(sfy) === 1) return fx === tx;
  if (Math.abs(sfx) === 1 && Math.abs(sfy) === 1) return Math.abs(tx - fx) === Math.abs(ty - fy);
  return false;
}
function squareAttacked(idx, byWhite) {
  for (let i=0;i<64;i++) {
    const p = board[i];
    if (!p) continue;
    if (byWhite ? !isWhite(p) : !isBlack(p)) continue;
    const piece = p.toUpperCase();
    const dir = byWhite ? -1 : 1;
    if (piece==='P') {
      for (const df of [-1,1]) {
        const cap = i + 8*dir + df;
        if (cap === idx && inBoardIdx(cap)) return true;
      }
    } else if (piece==='N') {
      for (const d of [15,17,6,10,-15,-17,-6,-10]) {
        const t = i + d;
        if (t===idx && inBoardIdx(t) && knightReach(i,t)) return true;
      }
    } else if (piece==='B' || piece==='R' || piece==='Q') {
      const dirs = [];
      if (piece!=='R') dirs.push(...[9,7,-9,-7]);
      if (piece!=='B') dirs.push(...[8,-8,1,-1]);
      for (const d of dirs) {
        let t = i + d;
        while (inBoardIdx(t) && sameLine(i,t,d)) {
          if (t===idx) return true;
          if (board[t]) break;
          t += d;
        }
      }
    } else if (piece==='K') {
      for (const d of [8,-8,1,-1,9,7,-9,-7]) {
        const t = i + d;
        if (t===idx && inBoardIdx(t) && kingReach(i,t)) return true;
      }
    }
  }
  return false;
}

function addPawnAdvance(moves, fromIdx, toIdx, whiteSide) {
  const toRank = Math.floor(toIdx/8);
  const promRank = whiteSide ? 0 : 7;
  if (toRank === promRank) {
    for (const promo of ['Q','R','B','N']) {
      moves.push({from:fromIdx,to:toIdx,piece:board[fromIdx],prom:promo,capture:null});
    }
  } else {
    moves.push({from:fromIdx,to:toIdx,piece:board[fromIdx],prom:null,capture:null});
  }
}

function generateMoves(whiteSide=true) {
  const moves = [];
  for (let i=0;i<64;i++) {
    const p = board[i];
    if (!p) continue;
    if (whiteSide ? !isWhite(p) : !isBlack(p)) continue;
    const piece = p.toUpperCase();
    const from = i;
    const dir = whiteSide ? -1 : 1;
    if (piece==='P') {
      const one = i + 8*dir;
      if (inBoardIdx(one) && !board[one]) {
        addPawnAdvance(moves, from, one, whiteSide);
        const startRank = whiteSide ? 6 : 1;
        const two = i + 16*dir;
        if (Math.floor(i/8) === startRank && !board[two] && !board[one]) {
          moves.push({from, to: two, piece: p, capture: null, prom: null, double: true});
        }
      }
      for (const df of [-1,1]) {
        const capIdx = i + 8*dir + df;
        if (!inBoardIdx(capIdx)) continue;
        const target = board[capIdx];
        if (target && (whiteSide ? isBlack(target) : isWhite(target))) {
          moves.push({from, to: capIdx, piece: p, capture: target, prom: null, enp: false});
        } else {
          const toCoord = idxToCoord(capIdx);
          if (enPassant === toCoord) {
            moves.push({from, to: capIdx, piece: p, capture: whiteSide ? 'p' : 'P', enp: true});
          }
        }
      }
    } else if (piece==='N') {
      for (const d of [15,17,6,10,-15,-17,-6,-10]) {
        const to = i + d;
        if (!inBoardIdx(to) || !knightReach(i,to)) continue;
        const t = board[to];
        if (!t || (whiteSide ? isBlack(t) : isWhite(t))) {
          moves.push({from, to, piece: p, capture: t || null});
        }
      }
    } else if (piece==='B' || piece==='R' || piece==='Q') {
      const dirs = [];
      if (piece!=='R') dirs.push(...[9,7,-9,-7]);
      if (piece!=='B') dirs.push(...[8,-8,1,-1]);
      for (const d of dirs) {
        let to = i + d;
        while (inBoardIdx(to) && sameLine(i,to,d)) {
          const t = board[to];
          if (!t) { moves.push({from, to, piece: p, capture: null}); }
          else {
            if (whiteSide ? isBlack(t) : isWhite(t)) moves.push({from, to, piece: p, capture: t});
            break;
          }
          to += d;
        }
      }
    } else if (piece==='K') {
      for (const d of [8,-8,1,-1,9,7,-9,-7]) {
        const to = i + d;
        if (!inBoardIdx(to) || !kingReach(i,to)) continue;
        const t = board[to];
        if (!t || (whiteSide ? isBlack(t) : isWhite(t))) {
          moves.push({from, to, piece: p, capture: t || null});
        }
      }
      if (whiteSide) {
        const e1 = coordToIdx('e1'), f1 = coordToIdx('f1'), g1 = coordToIdx('g1'), h1 = coordToIdx('h1'), d1 = coordToIdx('d1'), c1 = coordToIdx('c1'), b1 = coordToIdx('b1'), a1 = coordToIdx('a1');
        if (i===e1 && castleRights.K && !board[f1] && !board[g1] &&
            !squareAttacked(e1, false) && !squareAttacked(f1, false) && !squareAttacked(g1, false)) {
          moves.push({from:e1,to:g1,piece:p,castle:'K'});
        }
        if (i===e1 && castleRights.Q && !board[d1] && !board[c1] && !board[b1] &&
            !squareAttacked(e1, false) && !squareAttacked(d1, false) && !squareAttacked(c1, false)) {
          moves.push({from:e1,to:c1,piece:p,castle:'Q'});
        }
      } else {
        const e8 = coordToIdx('e8'), f8 = coordToIdx('f8'), g8 = coordToIdx('g8'), h8 = coordToIdx('h8'), d8 = coordToIdx('d8'), c8 = coordToIdx('c8'), b8 = coordToIdx('b8'), a8 = coordToIdx('a8');
        if (i===e8 && castleRights.k && !board[f8] && !board[g8] &&
            !squareAttacked(e8, true) && !squareAttacked(f8, true) && !squareAttacked(g8, true)) {
          moves.push({from:e8,to:g8,piece:p,castle:'k'});
        }
        if (i===e8 && castleRights.q && !board[d8] && !board[c8] && !board[b8] &&
            !squareAttacked(e8, true) && !squareAttacked(d8, true) && !squareAttacked(c8, true)) {
          moves.push({from:e8,to:c8,piece:p,castle:'q'});
        }
      }
    }
  }
  return moves.filter(m => !leavesKingInCheck(m, whiteSide));
}

function snapshotState() {
  return {
    board: board.slice(),
    whiteToMove,
    castleRights: {...castleRights},
    enPassant,
    halfmoveClock,
    fullmoveNumber
  };
}
function restoreSnapshot(s) {
  board = s.board.slice();
  whiteToMove = s.whiteToMove;
  castleRights = {...s.castleRights};
  enPassant = s.enPassant;
  halfmoveClock = s.halfmoveClock;
  fullmoveNumber = s.fullmoveNumber;
}

let _makeMove = function(move, opts={simulate:false}) {
  const from = move.from, to = move.to;
  const piece = board[from];
  if (move.enp) {
    const dir = isWhite(piece) ? -1 : 1;
    const behind = to - 8*dir;
    board[behind] = null;
  }
  if (move.castle) {
    if (move.castle==='K') { board[coordToIdx('f1')] = board[coordToIdx('h1')]; board[coordToIdx('h1')] = null; }
    else if (move.castle==='Q') { board[coordToIdx('d1')] = board[coordToIdx('a1')]; board[coordToIdx('a1')] = null; }
    else if (move.castle==='k') { board[coordToIdx('f8')] = board[coordToIdx('h8')]; board[coordToIdx('h8')] = null; }
    else if (move.castle==='q') { board[coordToIdx('d8')] = board[coordToIdx('a8')]; board[coordToIdx('a8')] = null; }
  }
  board[to] = move.prom ? (isWhite(piece) ? move.prom : move.prom.toLowerCase()) : piece;
  board[from] = null;
  if (move.double) {
    const toCoord = idxToCoord(to);
    const file = toCoord[0];
    const rank = parseInt(toCoord[1],10);
    const epRank = isWhite(piece) ? rank+1 : rank-1;
    enPassant = file + epRank;
  } else {
    enPassant = null;
  }
  const fromCoord = idxToCoord(from);
  const toCoord = idxToCoord(to);
  const pieceUpper = piece.toUpperCase();
  if (pieceUpper==='K') {
    if (isWhite(piece)) { castleRights.K=false; castleRights.Q=false; }
    else { castleRights.k=false; castleRights.q=false; }
  }
  if (pieceUpper==='R') {
    if (fromCoord==='h1' || toCoord==='h1') castleRights.K=false;
    if (fromCoord==='a1' || toCoord==='a1') castleRights.Q=false;
    if (fromCoord==='h8' || toCoord==='h8') castleRights.k=false;
    if (fromCoord==='a8' || toCoord==='a8') castleRights.q=false;
  }
  if (move.capture && move.capture.toUpperCase()==='R') {
    if (toCoord==='h1') castleRights.K=false;
    if (toCoord==='a1') castleRights.Q=false;
    if (toCoord==='h8') castleRights.k=false;
    if (toCoord==='a8') castleRights.q=false;
  }
  const isPawn = pieceUpper==='P';
  if (isPawn || move.capture) halfmoveClock = 0; else halfmoveClock++;
  if (!opts.simulate) {
    if (!whiteToMove) fullmoveNumber++;
    whiteToMove = !whiteToMove;
  }
};
const originalMakeMove = _makeMove;
function makeMove(move, opts={simulate:false}) {
  if (!opts.simulate) undoStack.push(snapshotState());
  originalMakeMove(move, opts);
}
function leavesKingInCheck(move, whiteSide) {
  const snap = snapshotState();
  originalMakeMove(move, {simulate:true});
  const kIdx = findKingIdx(whiteSide);
  const inCheckNow = squareAttacked(kIdx, !whiteSide);
  restoreSnapshot(snap);
  return inCheckNow;
}
function inCheck(whiteSide) {
  const k = findKingIdx(whiteSide);
  return squareAttacked(k, !whiteSide);
}
function isCheckmate(whiteSide) {
  if (!inCheck(whiteSide)) return false;
  return generateMoves(whiteSide).length === 0;
}
function isStalemate(whiteSide) {
  if (inCheck(whiteSide)) return false;
  return generateMoves(whiteSide).length === 0;
}

const val = { p:100, n:320, b:330, r:500, q:900, k:20000 };
const pstW = {
  p: [
    0,5,5,0,5,10,50,0, 0,10,-5,0,5,10,50,0, 0,10,-10,20,25,30,50,0, 0,20,0,30,35,40,50,0,
    0,25,5,35,40,45,55,0, 5,30,10,40,45,50,60,5, 10,35,20,50,55,60,70,10, 0,0,0,0,0,0,0,0
  ],
  n: [
    -50,-40,-30,-30,-30,-30,-40,-50, -40,-20,0,0,0,0,-20,-40, -30,0,10,15,15,10,0,-30, -30,5,15,20,20,15,5,-30,
    -30,0,15,20,20,15,0,-30, -30,5,10,15,15,10,5,-30, -40,-20,0,5,5,0,-20,-40, -50,-40,-30,-30,-30,-30,-40,-50
  ],
  b: [
    -20,-10,-10,-10,-10,-10,-10,-20, -10,0,0,0,0,0,0,-10, -10,0,5,10,10,5,0,-10, -10,5,5,10,10,5,5,-10,
    -10,0,10,10,10,10,0,-10, -10,10,10,10,10,10,10,-10, -10,5,0,0,0,0,5,-10, -20,-10,-10,-10,-10,-10,-10,-20
  ],
  r: [
    0,0,0,5,5,0,0,0, 5,10,10,10,10,10,10,5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5,
    -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, 0,0,0,5,5,0,0,0
  ],
  q: Array(64).fill(0),
  k: [
    20,30,10,0,0,10,30,20, 20,20,0,0,0,0,20,20, -10,-20,-20,-20,-20,-20,-20,-10, -20,-30,-30,-40,-40,-30,-30,-20,
    -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30
  ]
};
function pstScore(p, idx) {
  const isW = isWhite(p);
  const type = p.toLowerCase();
  const table = pstW[type] || Array(64).fill(0);
  const mirrorIdx = isW ? idx : (Math.floor(idx/8)*8 + (7-(idx%8)));
  return isW ? table[idx] : -table[mirrorIdx];
}
function evaluateBoard() {
  let score = 0;
  for (let i=0;i<64;i++) {
    const p = board[i];
    if (!p) continue;
    score += (isWhite(p) ? val[p.toLowerCase()] : -val[p.toLowerCase()]) + pstScore(p, i);
  }
  score += generateMoves(true).length * 2;
  score -= generateMoves(false).length * 2;
  return score;
}
function orderMoves(moves) {
  return moves.slice().sort((a,b)=>{
    const av = a.capture ? val[a.capture.toLowerCase()] - val[a.piece.toLowerCase()] : (a.prom?50:0);
    const bv = b.capture ? val[b.capture.toLowerCase()] - val[b.piece.toLowerCase()] : (b.prom?50:0);
    return bv - av;
  });
}
function aiPickMove(side, level) {
  const legal = generateMoves(side==='w');
  if (legal.length===0) return null;
  if (level===0) return legal[Math.floor(Math.random()*legal.length)];
  if (level<=2) {
    let best = null, bestScore = side==='w' ? -Infinity : Infinity;
    for (const mv of legal) {
      const snap = snapshotState();
      makeMove(mv);
      const sc = evaluateBoard();
      restoreSnapshot(snap);
      if (side==='w' ? sc>bestScore : sc<bestScore) { bestScore=sc; best=mv; }
    }
    return best || legal[0];
  }
  const depth = Math.min(level, 5);
  let bestMove = legal[0];
  let bestScore = side==='w' ? -Infinity : Infinity;
  for (const mv of orderMoves(legal)) {
    const snap = snapshotState();
    makeMove(mv);
    const sc = alphabeta(depth-1, -Infinity, Infinity, side!=='w');
    restoreSnapshot(snap);
    if (side==='w') { if (sc > bestScore) { bestScore = sc; bestMove = mv; } }
    else { if (sc < bestScore) { bestScore = sc; bestMove = mv; } }
  }
  return bestMove;
}
function alphabeta(depth, alpha, beta, whiteTurn) {
  if (depth===0) return evaluateBoard();
  const moves = orderMoves(generateMoves(whiteTurn));
  if (moves.length===0) {
    if (inCheck(whiteTurn)) return whiteTurn ? -999999 : 999999;
    return 0;
  }
  if (whiteTurn) {
    let value = -Infinity;
    for (const mv of moves) {
      const snap = snapshotState();
      makeMove(mv);
      value = Math.max(value, alphabeta(depth-1, alpha, beta, false));
      restoreSnapshot(snap);
      alpha = Math.max(alpha, value);
      if (alpha >= beta) break;
    }
    return value;
  } else {
    let value = Infinity;
    for (const mv of moves) {
      const snap = snapshotState();
      makeMove(mv);
      value = Math.min(value, alphabeta(depth-1, alpha, beta, true));
      restoreSnapshot(snap);
      beta = Math.min(beta, value);
      if (alpha >= beta) break;
    }
    return value;
  }
}

const boardEl = document.getElementById('board');
const historyEl = document.getElementById('history');
const messageEl = document.getElementById('message');
const moveSound = document.getElementById('moveSound');
const illegalSound = document.getElementById('illegalSound');

function applyLangTexts() {
  const t = i18n[state.lang];
  document.getElementById('newGameBtn').textContent = t.newGame;
  document.getElementById('flipBtn').textContent = t.flip;
  document.getElementById('undoBtn').textContent = t.undo;
  document.getElementById('langLabel').textContent = t.langLabel;
  document.getElementById('applyLang').textContent = t.applyLang;
  document.getElementById('startPrompt').textContent = t.startPrompt;
  document.getElementById('themeLabel').textContent = t.themeLabel;
  document.getElementById('lightLabel').textContent = t.lightLabel;
  document.getElementById('darkLabel').textContent = t.darkLabel;
  document.getElementById('whitePieceLabel').textContent = t.whitePieceLabel;
  document.getElementById('blackPieceLabel').textContent = t.blackPieceLabel;
  document.getElementById('applyTheme').textContent = t.applyTheme;
  document.getElementById('aiLabel').textContent = t.aiLabel;
  document.getElementById('applyAI').textContent = t.applyAI;
  renderStatus();
  renderHistoryHeader();
  applyDirection();
}
function applyDirection() {
  const rtl = state.lang === 'fa' || state.lang === 'ar';
  document.documentElement.setAttribute('dir', rtl ? 'rtl' : 'ltr');
  document.documentElement.setAttribute('lang', state.lang);
}
function applyTheme() {
  document.documentElement.style.setProperty('--board-light', state.theme.light);
  document.documentElement.style.setProperty('--board-dark', state.theme.dark);
  document.documentElement.style.setProperty('--piece-white-color', state.theme.pieceW);
  document.documentElement.style.setProperty('--piece-black-color', state.theme.pieceB);
  document.getElementById('lightColor').value = state.theme.light;
  document.getElementById('darkColor').value = state.theme.dark;
  document.getElementById('whitePieceColor').value = state.theme.pieceW;
  document.getElementById('blackPieceColor').value = state.theme.pieceB;
}
function pieceIcon(p) {
  const map = { 'P':'♙','R':'♖','N':'♘','B':'♗','Q':'♕','K':'♔', 'p':'♟','r':'♜','n':'♞','b':'♝','q':'♛','k':'♚' };
  return map[p] || '?';
}
function renderBoard() {
  boardEl.innerHTML = '';
  for (let r=0;r<8;r++) {
    for (let f=0;f<8;f++) {
      let rr = r, ff = f;
      if (state.flipped) { rr = 7-r; ff = 7-f; }
      const idx = rr*8 + ff;
      const sq = document.createElement('div');
      sq.className = 'square ' + (((r+f)%2===0) ? 'light' : 'dark');
      sq.dataset.idx = idx;
      const p = board[idx];
      if (p) {
        const pe = document.createElement('div');
        pe.className = 'piece ' + (isWhite(p) ? 'white' : 'black');
        pe.textContent = pieceIcon(p);
        pe.draggable = true;
        pe.dataset.idx = idx;
        sq.appendChild(pe);
      }
      boardEl.appendChild(sq);
    }
  }
  bindDragAndClick();
  renderStatus();
}
let selectedIdx = null;
let legalHints = [];
function bindDragAndClick() {
  const squares = [...document.querySelectorAll('.square')];
  const pieces = [...document.querySelectorAll('.piece')];
  squares.forEach(sq => {
    sq.addEventListener('click', () => {
      const idx = parseInt(sq.dataset.idx,10);
      const p = board[idx];
      if (p && ((whiteToMove && isWhite(p)) || (!whiteToMove && isBlack(p)))) {
        selectedIdx = idx;
        legalHints = generateMoves(whiteToMove).filter(m => m.from===idx).map(m => m.to);
        highlightSelection();
      } else if (selectedIdx !== null) {
        attemptMove(selectedIdx, idx);
      }
    });
  });
  pieces.forEach(pc => {
    pc.addEventListener('dragstart', (e) => {
      const idx = parseInt(pc.dataset.idx,10);
      if (!canDragPiece(idx)) { e.preventDefault(); illegalBlink(idx); return; }
      selectedIdx = idx;
      legalHints = generateMoves(whiteToMove).filter(m => m.from===idx).map(m => m.to);
      e.dataTransfer.setData('text/plain', idx.toString());
      highlightSelection();
    });
  });
  squares.forEach(sq => {
    sq.addEventListener('dragover', (e) => { e.preventDefault(); });
    sq.addEventListener('drop', (e) => {
      e.preventDefault();
      const from = selectedIdx ?? parseInt(e.dataTransfer.getData('text/plain'),10);
      const to = parseInt(sq.dataset.idx,10);
      attemptMove(from, to);
    });
  });
}
function canDragPiece(idx) {
  const p = board[idx];
  if (!p) return false;
  if (whiteToMove && !isWhite(p)) return false;
  if (!whiteToMove && !isBlack(p)) return false;
  return true;
}
function highlightSelection() {
  document.querySelectorAll('.square').forEach(s => s.classList.remove('highlight','hint'));
  if (selectedIdx===null) return;
  const selSq = [...document.querySelectorAll('.square')].find(s => parseInt(s.dataset.idx,10)===selectedIdx);
  if (selSq) selSq.classList.add('highlight');
  legalHints.forEach(to => {
    const tSq = [...document.querySelectorAll('.square')].find(s => parseInt(s.dataset.idx,10)===to);
    if (tSq) tSq.classList.add('hint');
  });
}
function illegalBlink(idx) {
  const sq = [...document.querySelectorAll('.square')].find(s => parseInt(s.dataset.idx,10)===idx);
  if (sq) { sq.classList.add('illegal'); setTimeout(()=>sq.classList.remove('illegal'),300); }
  showMessage(i18n[state.lang].illegal, 'warning');
  illegalSound.currentTime = 0; illegalSound.play().catch(()=>{});
}
function attemptMove(fromIdx, toIdx) {
  const legal = generateMoves(whiteToMove);
  const mv = legal.find(m => m.from===fromIdx && m.to===toIdx);
  if (!mv) { illegalBlink(fromIdx); selectedIdx=null; legalHints=[]; highlightSelection(); return; }
  const san = toSAN(mv);
  makeMove(mv);
  history.push(san);
  renderBoard();
  renderHistory();
  moveSound.currentTime = 0; moveSound.play().catch(()=>{});
  showMessage(i18n[state.lang].moved, 'ok');
  selectedIdx = null; legalHints = []; highlightSelection();
  maybeAITurn();
}
function toSAN(mv) {
  const from = idxToCoord(mv.from);
  const to = idxToCoord(mv.to);
  const p = mv.piece.toUpperCase();
  if (mv.castle==='K' || mv.castle==='k') return 'O-O';
  if (mv.castle==='Q' || mv.castle==='q') return 'O-O-O';
  const pieceChar = (p==='P') ? '' : p;
  const capture = mv.capture ? 'x' : '';
  const promo = mv.prom ? '='+mv.prom : '';
  return pieceChar + (capture ? from[0] : '') + capture + to + promo;
}
function renderHistoryHeader() {
  const t = i18n[state.lang].historyTitle;
  const hdr = document.createElement('div');
  hdr.className = 'history-item';
  hdr.innerHTML = `<div class="num">#</div><div>${t}</div><div></div>`;
  historyEl.innerHTML = '';
  historyEl.appendChild(hdr);
}
function renderHistory() {
  renderHistoryHeader();
  for (let i=0;i<history.length;i+=2) {
    const whiteMove = history[i] || '';
    const blackMove = history[i+1] || '';
    const row = document.createElement('div');
    row.className = 'history-item';
    row.innerHTML = `<div class="num">${Math.floor(i/2)+1}.</div><div>${whiteMove}</div><div>${blackMove}</div>`;
    historyEl.appendChild(row);
  }
  historyEl.scrollTop = historyEl.scrollHeight;
}
function renderStatus() {
  const t = i18n[state.lang];
  document.getElementById('turnBadge').textContent = whiteToMove ? t.turnWhite : t.turnBlack;
  let s = t.statePlaying;
  if (isCheckmate(whiteToMove)) s = t.stateMate;
  else if (isStalemate(whiteToMove)) s = t.stateStalemate;
  else if (inCheck(whiteToMove)) s = t.stateCheck;
  document.getElementById('stateBadge').textContent = s;
}
function showMessage(text, type='info') {
  messageEl.innerHTML = `<span class="${type==='warning' ? 'warning' : 'ok'}">${text}</span>`;
  setTimeout(()=>{ messageEl.textContent=''; }, 2000);
}
function maybeAITurn() {
  const aiS = state.aiSide;
  const sideToMove = whiteToMove ? 'w' : 'b';
  if (aiS !== sideToMove) return;
  const mv = aiPickMove(aiS, state.aiLevel);
  if (!mv) return;
  setTimeout(() => {
    const san = toSAN(mv);
    makeMove(mv);
    history.push(san);
    renderBoard();
    renderHistory();
    moveSound.currentTime = 0; moveSound.play().catch(()=>{});
    renderStatus();
  }, 180);
}

document.getElementById('newGameBtn').addEventListener('click', () => {
  loadFEN(initialFEN);
  renderBoard();
  renderHistory();
});
document.getElementById('flipBtn').addEventListener('click', () => {
  state.flipped = !state.flipped;
  renderBoard();
});
document.getElementById('undoBtn').addEventListener('click', () => {
  if (!undoStack.length) { showMessage(i18n[state.lang].illegal, 'warning'); return; }
  const snap = undoStack.pop();
  restoreSnapshot(snap);
  if (history.length) history.pop();
  renderBoard();
  renderHistory();
});
document.getElementById('langSelect').value = state.lang;
document.getElementById('applyLang').addEventListener('click', () => {
  state.lang = document.getElementById('langSelect').value;
  localStorage.setItem('chess_lang', state.lang);
  applyLangTexts();
  renderBoard();
  renderHistory();
});
document.getElementById('applyTheme').addEventListener('click', () => {
  state.theme.light = document.getElementById('lightColor').value;
  state.theme.dark = document.getElementById('darkColor').value;
  state.theme.pieceW = document.getElementById('whitePieceColor').value;
  state.theme.pieceB = document.getElementById('blackPieceColor').value;
  localStorage.setItem('chess_light', state.theme.light);
  localStorage.setItem('chess_dark', state.theme.dark);
  localStorage.setItem('chess_pieceW', state.theme.pieceW);
  localStorage.setItem('chess_pieceB', state.theme.pieceB);
  applyTheme();
  renderBoard();
});
document.getElementById('applyAI').addEventListener('click', () => {
  state.aiSide = document.getElementById('aiSide').value;
  state.aiLevel = parseInt(document.getElementById('aiLevel').value, 10);
  localStorage.setItem('chess_ai_side', state.aiSide);
  localStorage.setItem('chess_ai_level', state.aiLevel.toString());
  renderStatus();
  maybeAITurn();
});
function boot() {
  applyLangTexts();
  applyTheme();
  loadFEN(initialFEN);
  renderBoard();
  renderHistory();
  showMessage(i18n[state.lang].startPrompt, 'warning');
}
boot();
</script>
</body>
</html>
